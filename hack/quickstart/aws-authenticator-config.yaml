# a unique-per-cluster identifier to prevent replay attacks (see above)
clusterID: bootkube-cluster
server:
  # state directory for generated TLS certificate and private keys
  stateDir: /var/aws-authenticator
  generateKubeconfig: /var/aws-authenticator/kubeconfig.yaml
  # each mapRoles entry maps an IAM role to a username and set of groups
  # Each username and group can optionally contain template parameters:
  #  1) "{{AccountID}}" is the 12 digit AWS ID.
  #  2) "{{SessionName}}" is the role session name.
  mapRoles:
  # statically map arn:aws:iam::000000000000:role/KubernetesAdmin to cluster admin
  #- roleARN: arn:aws:iam::000000000000:role/KubernetesAdmin
  #  username: kubernetes-admin
  #  groups:
  #  - system:masters
  # map EC2 instances in my "KubernetesNode" role to users like
  # "aws:000000000000:instance:i-0123456789abcdef0". Only use this if you
  # trust that the role can only be assumed by EC2 instances. If an IAM user
  # can assume this role directly (with sts:AssumeRole) they can control
  # SessionName.
  #- roleARN: arn:aws:iam::000000000000:role/KubernetesNode
  #  username: aws:{{AccountID}}:instance:{{SessionName}}
  #  groups:
  #  - system:bootstrappers
  #  - aws:instances
  # map federated users in my "KubernetesAdmin" role to users like
  # "admin:alice-example.com". The SessionName is an arbitrary role name
  # like an e-mail address passed by the identity provider. Note that if this
  # role is assumed directly by an IAM User (not via federation), the user
  # can control the SessionName.
  #- roleARN: arn:aws:iam::000000000000:role/KubernetesAdmin
  #  username: admin:{{SessionName}}
  #  groups:
  #  - system:masters
  # each mapUsers entry maps an IAM role to a static username and set of groups
  mapUsers:
  # map user IAM user Alice in 000000000000 to user "alice" in group "system:masters"
  #- userARN: arn:aws:iam::000000000000:user/Alice
  #  username: alice
  #  groups:
  #  - system:masters